
fact := (fix .[ again : [ -> [ Int -> Int ]] .  .[ n : Int . match (zero? n) { +[True]+ => one  +[False]+ => (times n ((again) (minus n one))) } ]. ].)
List t= forall T . mu_type List . enum { Nil () Cons (T List <[T]<) }
ListUF t= forall T . enum { Nil () Cons (T List <[T]<) }
nil := forall T . .[ . fold +[Nil]+ : ListUF <[T]< : List <[T]<].
cons := forall T . .[hd : T  tl : List <[T]< . fold +[Cons hd tl]+ : ListUF <[T]< : List <[T]<].
empty_list := (nil)
3_list := (cons three empty_list)
23_list := (cons two 3_list)
123_list := (cons one 23_list)
sum_list := (fix .[again : [-> [List <[Int]< -> Int]] . .[ lst : List <[Int]< . match unfold lst { +[Nil]+ => zero +[Cons hd tl]+ => (plus hd ((again) tl))} ]. ]. )
list_len := forall T . (fix .[again : [-> [List <[T]< -> Int]] . .[ lst : List <[T]< . match unfold lst { +[Nil]+ => zero +[Cons hd tl]+ => (plus one ((again) tl))} ]. ].)
# `match` requires its arms to have exactly identical types. That keeps us from being able to use `cons` and `nil` in this definition ) :
# map := forall T S . (fix .[again : [-> [[T -> S]  List <[T]< -> List <[S]< ]] . .[f : [T -> S] lst : List <[T]< . match unfold lst { +[Nil]+ => fold +[Nil]+ : ListUF <[S]< : List <[S]< +[Cons hd tl]+ =>  fold +[Cons (f hd) ((again) f tl)]+ : ListUF <[S]< : List <[S]< } ]. ].)
reduce := forall Elt Res . (fix .[again : [-> [List <[Elt]<  [Elt Res -> Res] Res -> Res ]] . .[ lst : List <[Elt]<   f : [Elt Res -> Res] seed : Res . match unfold lst { +[Nil]+ => seed   +[Cons hd tl]+ =>  (f hd ((again) tl f seed)) } ]. ].)
# ...but this definition of `map` is nice:
map := forall T S . (fix .[again : [-> [[T -> S] List <[T]< -> List <[S]<]] . .[ f : [T -> S] lst : List <[T]< . (reduce lst .[elt : T  res : List <[S]< . (cons (f elt) res)]. (nil)) ]. ].)

TODO:
  [ ] Core forms for core types
  [ ] Syntax types, with repetition typing
  [ ] Syntax pattern-matching
  [ ] Name freshening on destructuring
  [ ] Syntax quote
  [ ] Macros (procedural!)
  [ ] Traits  
  [ ] Fancy bindings
  [ ] Modules
  [ ] Kinds?
  [ ] Switchable tokenizer
  [ ] Worry about parse error messages


Like a normal language implementation, we have 
 a reader that turns text into tokens,
 a parser that turns tokens into AST,
 a typechecker that validates an AST,
 a macro expander that transforms
  an AST with user-defined forms
  into an AST in a core language,
 and an evaluator that turns ASTs into behavior.
Unlike a normal language implementation,
 the typechecker runs before the macro expander.
This means that the typechecker has to operate on
 user-defined AST nodes,
  which is possible,
   because (I think) one can derive a typechecker for a form
    from the type of its definition.
The weirdness of this language implementation starts with the AST.

Well, the parser and tokenizer are weird, but in a sort of optional way.
 




 Pipeline:
                             ⋮              ⋮           ⋮
                      →  [TypeSynth]  →  [Expand] →  [Evaluate] ↩ (phase 2)
                      →  [TypeSynth]  →  [Expand] →  [Evaluate] ↩ (phase 1)
  [Read]  →  [Parse]  →  [TypeSynth]  →  [Expand] →  [Evaluate] (runtime)
          ↑           ↑               ↑           ↑
      TokenTree      Ast           Ast:Ty      Ast:Ty (core) 

[Read] read.rs
  The reader is very simple.
  Tokens boundaries are whitespace and the inside boundaries of ()[]{}. 
  If a token ends with ([{,
   it should match a token that is identical
    except for starting with )]} instead.

[Parse] parse.rs
  The parser has to parse arbitrary grammars (`FormPat`s).
  Furthermore, it must be able to 
   extend the grammar it is currently parsing 
    (it does this by extending `SynEnv`), 
   and generate new `Form`s.
  Extending the grammar may entail invoking the rest of the pipeline
   (Typesynth and Evaluate),
   the timing of which should be controlled by phasing.

[TypeSynth] ty.rs
  Type synthesis for core forms.

  It should be possible to derive type synthesis for macros! 
  Synthesize a type for the macro body, and it'll tell you what you get.
  I think.
  If not, there's not much point to making this language.
  
  Type synthesis and evaluation are both driven by ast_walk.rs.

[Evaluate] eval.rs
  Evaluation is a tree traversal, surprisingly similar to type synthesis.
  
  Maybe at some point, this will be translation into some other language
    (like Rust?),
   but it's probably faster to interpret 
    the many small programs that macros are.
    
[↩ (Reflection)] reify.rs
  Macros are programs that manipulate `Ast`s 
   (they can also access environments).
  We need to reflect internal `Ast`s into Unseemly values
   and reify them back out.
  
  Fun fact: `Ast` transitively includes  
   almost every type in the compiler.
  So we use a macro (see reification_macros.rs) 
    to generate the reification/reflection, 
   rather than do it by hand.
  
  

Crucial data structures:

  `Name` name.rs
    Will contain hygiene metadata, eventually

  `TokenTree` read.rs
    The result of reading; a tree with nodes at every ()[]{}

  `FormPat` parse.rs
    Grammar for forms (core and user-defined)

  `Form` form.rs
    Everything one needs to know about a language form. Contains:
     * `grammar : FormPat` [Parse] -- grammar (how we know the user used the form)
       Also contains:
       * how things should bind
       * grammar "binding" information (syntax extension)
       * TODO: phase information
     * `synth_type : WalkRule` [TypeSynth] -- typechecking rule
     * `eval : WalkRule` [Evaluate] -- evaluation rule
     * TODO [misc] -- pretty-printing information

  `Ast` ast.rs
    Syntax, in its logical structure.
  
  `Beta` beta.rs
    How terms bind. Surprisingly important!

  `SynEnv` parse.rs
    Indicates what the grammar is at a particular point. 
    [Map from [named grammar nodes] to `FormPat`]
    
  `EnvMBE` util/mbe.rs
    Ergonomic (...in a sense) representation for the contents of `Ast` nodes
     which have parts that can repeat `n` times.



Questions: 

What if a macro like Rust's `try!` 
 has a type error in its return value?
What happens? What should happen? 
 TODO:
  [ ] Kinds
  [ ] Parametric types, enums, structs, recursive types
  [ ] Core forms for those types
  [ ] Prelude types, values, and functions (normal and syntax)
  [ ] Syntax pattern-matching
  [ ] Macros (procedural!)
  [ ] Traits  
  [ ] Syntax quote
  [ ] Fancy bindings
  [ ] Modules




 Pipeline:
                             ⋮              ⋮
                      →  [TypeSynth]  →  [Evaluate] ↩ (phase 2)
                      →  [TypeSynth]  →  [Evaluate] ↩ (phase 1)
  [Read]  →  [Parse]  →  [TypeSynth]  →  [Evaluate] (phase 0: runtime)
          ↑           ↑               ↑
      TokenTree      Ast           Ast:Ast

[Read] read.rs
  The reader is very simple.
  Tokens boundaries are whitespace and the inside boundaries of ()[]{}. 
  If a token ends with ([{, 
   it should match a token that is identical
    except for starting with )]} instead.

[Parse] parse.rs
  The parser has to parse arbitrary grammars (`FormPat`s).
  Furthermore, it must be able to 
   extend the grammar it is currently parsing 
    (it does this by extending `SynEnv`), 
   and generate new `Form`s.
  Extending the grammar may entail invoking the rest of the pipeline
   (Typesynth and Evaluate),
   the timing of which should be controlled by phasing.

[TypeSynth] ty.rs
  Type synthesis for core forms.

  It should be possible to derive type synthesis for macros! 
  Synthesize a type for the macro body, and it'll tell you what you get.
  I think.
  
  Type synthesis and evaluation are both driven by ast_walk.rs.

[Evaluate] eval.rs
  Evaluation is a tree traversal, suprisingly similar to type synthesis.

Crucial data structures:

  `Name` name.rs
    Will contain hygiene metadata, eventually

  `TokenTree` read.rs
    The result of reading; a tree with nodes at every ()[]{}

  `FormPat` parse.rs
    Grammar for forms (core and user-defined)

  `Form` form.rs
    Everything one needs to know about a language form. Contains:
     * `grammar : FormPat` [Parse] -- grammar (how we know the user used the form)
       Also contains:
       * binding information
       * grammar "binding" information (syntax extension)
       * TODO: phase information
     * `synth_type : WalkRule` [TypeSynth] -- typechecking rule
     * `eval : WalkRule` [Evaluate] -- evaluation rule
     * TODO [misc] -- pretty-printing information

  `Ast` ast.rs
    Syntax, in its logical structure.

  `SynEnv` parse.rs
    Indicates what the grammar is at a particular point. 
    [Map from [named grammar nodes] to `FormPat`]



Questions: 

What if a macro like Rust's `try!` 
 has a type error in its return value?
What happens? What should happen? 